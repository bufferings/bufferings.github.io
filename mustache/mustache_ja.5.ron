mustache(5) -- Logic-less templates.
====================================
(2014-04-19 Translated by @bufferins)

## SYNOPSIS: 概要

<!--
A typical Mustache template:
-->
典型的なMustacheのテンプレートはこんな感じです:

    Hello {{name}}
    You have just won {{value}} dollars!
    {{#in_ca}}
    Well, {{taxed_value}} dollars, after taxes.
    {{/in_ca}}

<!--
Given the following hash:
-->
これに、次のようなハッシュを与えます:

    {
      "name": "Chris",
      "value": 10000,
      "taxed_value": 10000 - (10000 * 0.4),
      "in_ca": true
    }

<!--
Will produce the following:
-->
するとこんな風になります:

    Hello Chris
    You have just won 10000 dollars!
    Well, 6000.0 dollars, after taxes.


## DESCRIPTION: 説明

<!--
Mustache can be used for HTML, config files, source code -
anything. It works by expanding tags in a template using values
provided in a hash or object.
-->
MustacheはHTMLにも、設定ファイルにも、ソースコードにも -
何にでも使用できます。ハッシュやオブジェクトから取得した値を使用して
テンプレート内のタグを展開することによって動作します。

<!--
We call it "logic-less" because there are no if statements, else
clauses, or for loops. Instead there are only tags. Some tags are
replaced with a value, some nothing, and others a series of
values. This document explains the different types of Mustache tags.
-->
私達はMustacheのことを"ロジックレス"と呼んでいます。理由は、ifステートメントも
else節も、forループもないからです。その代わりにタグしかありません。
タグの中には値で置き換えられるものと、置き換えられないものと、
複数の値で置き換えられるものがあります。このドキュメントでは異なるタイプの
Mustacheタグについて説明します。


## TAG TYPES: タグのタイプ

<!--
Tags are indicated by the double mustaches. `{{person}}` is a tag, as
is `{{#person}}`. In both examples, we'd refer to `person` as the key
or tag key. Let's talk about the different types of tags.
-->
タグは二重のmustache(波括弧)によって表現されます。`{{person}}` はタグです。
同様に `{{#person}}` もタグです。どちらの例でも `person` のことをキーまたは
タグキーと呼びます。それでは異なるタイプのタグについてお話しましょう。

### Variables: 変数

<!--
The most basic tag type is the variable. A `{{name}}` tag in a basic
template will try to find the `name` key in the current context. If
there is no `name` key, the parent contexts will be checked recursively.
If the top context is reached and the `name` key is still not found,
nothing will be rendered.
-->
最も基本的なタグタイプは変数です。基本的なテンプレート内に `{{name}}` というタグがあると、
現在のコンテキストから `name` というキーを探そうとします。もし `name` キーがなければ
親コンテキストを再帰的にチェックします。もしトップコンテキストまでいっても `name` キーが
見つからない場合は、何もレンダリングされません。

<!--
All variables are HTML escaped by default. If you want to return
unescaped HTML, use the triple mustache: `{{{name}}}`.
-->
デフォルトで全ての変数はHTMLエスケープされます。もし、エスケープせずに出力したい場合は
三重mustacheを使用してください: `{{{name}}}`

<!--
You can also use `&` to unescape a variable: `{{& name}}`. This may be
useful when changing delimiters (see "Set Delimiter" below).
-->
また `&` を使用することでも変数をエスケープせずに出力できます: `{{& name}}`
これは区切り文字を変更する際に便利かもしれません(後述"区切り文字の指定"を参照してください)。

<!--
By default a variable "miss" returns an empty string. This can usually
be configured in your Mustache library. The Ruby version of Mustache
supports raising an exception in this situation, for instance.
-->
デフォルトでは"miss"という変数は空の文字列を返します。これは通常、
あなたの使用しているMustacheライブラリで設定することができます。
例えば、MustacheのRubyバージョンでは、この場合には例外が発生します。

Template:

    * {{name}}
    * {{age}}
    * {{company}}
    * {{{company}}}

Hash:

    {
      "name": "Chris",
      "company": "<b>GitHub</b>"
    }

Output:

    * Chris
    *
    * &lt;b&gt;GitHub&lt;/b&gt;
    * <b>GitHub</b>


### Sections: セクション

<!--
Sections render blocks of text one or more times, depending on the
value of the key in the current context.
-->
セクションはテキストブロックを1回以上レンダリングします。
それは、現在のコンテキストのキーの値によって決まります。

<!--
A section begins with a pound and ends with a slash. That is,
`{{#person}}` begins a "person" section while `{{/person}}` ends it.
-->
セクションは井桁で始まってスラッシュで終わります。つまり `{{#person}}` で
"person"セクションが始まり `{{/person}}` で終わるということです。

<!--
The behavior of the section is determined by the value of the key.
-->
セクションの動作はキーの値によって決まります。

**False Values or Empty Lists: False値または空のリスト**

<!--
If the `person` key exists and has a value of false or an empty
list, the HTML between the pound and slash will not be displayed.
-->
`person` キーが存在して、その値がfalseまたは空リストの場合、
井桁とスラッシュの間のHTMLは表示されません。

Template:

    Shown.
    {{#person}}
      Never shown!
    {{/person}}

Hash:

    {
      "person": false
    }

Output:

    Shown.

**Non-Empty Lists: 空ではないリスト**

<!--
If the `person` key exists and has a non-false value, the HTML between
the pound and slash will be rendered and displayed one or more times.
-->
`person` キーが存在して、値がfalseでない場合、井桁とスラッシュの間の
HTMLはレンダリングされ、複数回表示されます。

<!--
When the value is a non-empty list, the text in the block will be
displayed once for each item in the list. The context of the block
will be set to the current item for each iteration. In this way we can
loop over collections.
-->
値が空ではないリストの場合、リストの要素数分だけブロック内のテキストが表示されます。
ブロックのコンテキストは繰り返し処理の中の現在の要素になります。
このようにしてコレクションをループさせることができます。

Template:

    {{#repo}}
      <b>{{name}}</b>
    {{/repo}}

Hash:

    {
      "repo": [
        { "name": "resque" },
        { "name": "hub" },
        { "name": "rip" }
      ]
    }

Output:

    <b>resque</b>
    <b>hub</b>
    <b>rip</b>

**Lambdas: ラムダ**


<!--
When the value is a callable object, such as a function or lambda, the
object will be invoked and passed the block of text. The text passed
is the literal block, unrendered. `{{tags}}` will not have been expanded
- the lambda should do that on its own. In this way you can implement
filters or caching.
-->
値が呼び出し可能オブジェクトの場合、例えば関数やラムダの場合、
そのオブジェクトが呼び出され、テキストのブロックが渡されます。渡されるテキストは
文字列ブロックでありレンダリングされていません。 `{{tags}}` は展開されません。
ラムダが自分自身でレンダリングすべきです。このようにしてフィルターやキャッシュを実現できます。

Template:

    {{#wrapped}}
      {{name}} is awesome.
    {{/wrapped}}

Hash:

    {
      "name": "Willy",
      "wrapped": function() {
        return function(text, render) {
          return "<b>" + render(text) + "</b>"
        }
      }
    }

Output:

    <b>Willy is awesome.</b>

**Non-False Values: Falseではない値**

<!--
When the value is non-false but not a list, it will be used as the
context for a single rendering of the block.
-->
値がfalseでもリストでもない場合、ブロックを1度だけレンダリングするコンテキスト
として使用されます。

Template:

    {{#person?}}
      Hi {{name}}!
    {{/person?}}

Hash:

    {
      "person?": { "name": "Jon" }
    }

Output:

    Hi Jon!


### Inverted Sections: 逆セクション

<!--
An inverted section begins with a caret (hat) and ends with a
slash. That is `{{^person}}` begins a "person" inverted section while
`{{/person}}` ends it.
-->
逆セクションはハットで始まり、スラッシュで終わります。つまり
`{{^person}}` で"person"逆セクションが始まり `{{/person}}` で終わるということです。

<!--
While sections can be used to render text one or more times based on the
value of the key, inverted sections may render text once based
on the inverse value of the key. That is, they will be rendered
if the key doesn't exist, is false, or is an empty list.
-->
セクションはキーの値によって1回以上テキストをレンダリングするためのものですが、
逆セクションはキーの逆値にもとづいてテキストをレンダリングします。
つまり、キーが存在しない場合、falseの場合、または空リストの場合にレンダリングされる
ということです。

Template:

    {{#repo}}
      <b>{{name}}</b>
    {{/repo}}
    {{^repo}}
      No repos :(
    {{/repo}}

Hash:

    {
      "repo": []
    }

Output:

    No repos :(


### Comments: コメント

<!--
Comments begin with a bang and are ignored. The following template:
-->
コメントはビックリマークで始まって、無視されます。例えばこんなテンプレートは:

    <h1>Today{{! ignore me }}.</h1>

<!--
Will render as follows:
-->
次のようにレンダリングされます:

    <h1>Today.</h1>

<!--
Comments may contain newlines.
-->
コメントは改行を含むこともできます。


### Partials: パーシャル

<!--
Partials begin with a greater than sign, like `{{&gt; box}}`.
-->
パーシャルは大なり記号で始まります: `{{> box}}`

<!--
Partials are rendered at runtime (as opposed to compile time), so
recursive partials are possible. Just avoid infinite loops.
-->
パーシャルは(コンパイル時ではなく)ランタイム時にレンダリングされます。
そのため、パーシャルは再帰が可能です。でも、無限ループは避けてね。

<!--
They also inherit the calling context. Whereas in ERB you may have
this:
-->
また、呼び出し元のコンテキストが継承されます。例えばERBだとこのようになるのですが:

    <%= partial :next_more, :start => start, :size => size %>

<!--
Mustache requires only this:
-->
Mustacheはこれだけです:

    {{> next_more}}

<!--
Why? Because the `next_more.mustache` file will inherit the `size` and
`start` methods from the calling context.
-->
なぜでしょうか？それは `next_more.mustache` ファイルが呼び出し元のコンテキストの
`size` と `start` を継承するからです。

<!--
In this way you may want to think of partials as includes, or template
expansion, even though it's not literally true.
-->
このようにして、パーシャルをインクルードやテンプレート拡張として使用することができます。
文字通りではありませんが。

<!--
For example, this template and partial:
-->
例えば、このテンプレートとパーシャルを使用すると:

    base.mustache:
    <h2>Names</h2>
    {{#names}}
      {{> user}}
    {{/names}}

    user.mustache:
    <strong>{{name}}</strong>

<!--
Can be thought of as a single, expanded template:
-->
このように1つのテンプレートに展開されたテンプレートのように考えられます:

    <h2>Names</h2>
    {{#names}}
      <strong>{{name}}</strong>
    {{/names}}


### Set Delimiter: 区切り文字の指定

<!--
Set Delimiter tags start with an equal sign and change the tag
delimiters from `{{` and `}}` to custom strings.
-->
区切り文字指定タグはイコール記号で始まり、
区切り文字を `{{` と `}}` からカスタム文字列に変更します。


<!--
Consider the following contrived example:
-->
例を見てみましょう:

    * {{default_tags}}
    {{=<% %>=}}
    * <% erb_style_tags %>
    <%={{ }}=%>
    * {{ default_tags_again }}

<!--
Here we have a list with three items. The first item uses the default
tag style, the second uses erb style as defined by the Set Delimiter
tag, and the third returns to the default style after yet another Set
Delimiter declaration.
-->
3つの要素をもつリストがあります。最初の要素はデフォルトタグスタイルです。
2番目は、区切り文字指定タグで指定されたERBスタイル。
そして3番目は、再度区切り文字指定タグで指定されて、デフォルトタグに戻っています。

<!--
According to [ctemplates][ct], this "is useful for languages like TeX, where
double-braces may occur in the text and are awkward to use for
markup."
-->
[ctemplates][ct] によるとこれは "Texのような言語にとって有用です。
二重括弧がテキストの中に出てきて、マークアップとして使用するのに不便な場合があるのです。"

<!--
Custom delimiters may not contain whitespace or the equals sign.
-->
空白文字列やイコール記号はカスタム区切り文字としては使用できません。

[ct]: http://google-ctemplate.googlecode.com/svn/trunk/doc/howto.html


## COPYRIGHT

Mustache is Copyright (C) 2009 Chris Wanstrath

Original CTemplate by Google


## SEE ALSO

mustache(1),
<http://mustache.github.io/>
