.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "MUSTACHE" "5" "April 2014" "" ""
.
.SH "NAME"
\fBmustache\fR \- Logic\-less templates\.
.
.P
(2014\-04\-19 Translated by @bufferins)
.
.SH "SYNOPSIS: 概要"
典型的なMustacheのテンプレートはこんな感じです:
.
.IP "" 4
.
.nf

Hello {{name}}
You have just won {{value}} dollars!
{{#in_ca}}
Well, {{taxed_value}} dollars, after taxes\.
{{/in_ca}}
.
.fi
.
.IP "" 0
.
.P
これに、次のようなハッシュを与えます:
.
.IP "" 4
.
.nf

{
  "name": "Chris",
  "value": 10000,
  "taxed_value": 10000 \- (10000 * 0\.4),
  "in_ca": true
}
.
.fi
.
.IP "" 0
.
.P
するとこんな風になります:
.
.IP "" 4
.
.nf

Hello Chris
You have just won 10000 dollars!
Well, 6000\.0 dollars, after taxes\.
.
.fi
.
.IP "" 0
.
.SH "DESCRIPTION: 説明"
MustacheはHTMLにも、設定ファイルにも、ソースコードにも \- 何にでも使用できます。ハッシュやオブジェクトから取得した値を使用して テンプレート内のタグを展開することによって動作します。
.
.P
私達はMustacheのことを"ロジックレス"と呼んでいます。理由は、ifステートメントも else節も、forループもないからです。その代わりにタグしかありません。 タグの中には値で置き換えられるものと、置き換えられないものと、 複数の値で置き換えられるものがあります。このドキュメントでは異なるタイプの Mustacheタグについて説明します。
.
.SH "TAG TYPES: タグのタイプ"
タグは二重のmustache(波括弧)によって表現されます。\fB{{person}}\fR はタグです。 同様に \fB{{#person}}\fR もタグです。どちらの例でも \fBperson\fR のことをキーまたは タグキーと呼びます。それでは異なるタイプのタグについてお話しましょう。
.
.SS "Variables: 変数"
最も基本的なタグタイプは変数です。基本的なテンプレート内に \fB{{name}}\fR というタグがあると、 現在のコンテキストから \fBname\fR というキーを探そうとします。もし \fBname\fR キーがなければ 親コンテキストを再帰的にチェックします。もしトップコンテキストまでいっても \fBname\fR キーが 見つからない場合は、何もレンダリングされません。
.
.P
デフォルトで全ての変数はHTMLエスケープされます。もし、エスケープせずに出力したい場合は 三重mustacheを使用してください: \fB{{{name}}}\fR
.
.P
また \fB&\fR を使用することでも変数をエスケープせずに出力できます: \fB{{& name}}\fR これは区切り文字を変更する際に便利かもしれません(後述"区切り文字の指定"を参照してください)。
.
.P
デフォルトでは"miss"という変数は空の文字列を返します。これは通常、 あなたの使用しているMustacheライブラリで設定することができます。 例えば、MustacheのRubyバージョンでは、この場合には例外が発生します。
.
.P
Template:
.
.IP "" 4
.
.nf

* {{name}}
* {{age}}
* {{company}}
* {{{company}}}
.
.fi
.
.IP "" 0
.
.P
Hash:
.
.IP "" 4
.
.nf

{
  "name": "Chris",
  "company": "<b>GitHub</b>"
}
.
.fi
.
.IP "" 0
.
.P
Output:
.
.IP "" 4
.
.nf

* Chris
*
* &lt;b&gt;GitHub&lt;/b&gt;
* <b>GitHub</b>
.
.fi
.
.IP "" 0
.
.SS "Sections: セクション"
セクションはテキストブロックを1回以上レンダリングします。 それは、現在のコンテキストのキーの値によって決まります。
.
.P
セクションは井桁で始まってスラッシュで終わります。つまり \fB{{#person}}\fR で "person"セクションが始まり \fB{{/person}}\fR で終わるということです。
.
.P
セクションの動作はキーの値によって決まります。
.
.P
\fBFalse Values or Empty Lists: False値または空のリスト\fR
.
.P
\fBperson\fR キーが存在して、その値がfalseまたは空リストの場合、 井桁とスラッシュの間のHTMLは表示されません。
.
.P
Template:
.
.IP "" 4
.
.nf

Shown\.
{{#person}}
  Never shown!
{{/person}}
.
.fi
.
.IP "" 0
.
.P
Hash:
.
.IP "" 4
.
.nf

{
  "person": false
}
.
.fi
.
.IP "" 0
.
.P
Output:
.
.IP "" 4
.
.nf

Shown\.
.
.fi
.
.IP "" 0
.
.P
\fBNon\-Empty Lists: 空ではないリスト\fR
.
.P
\fBperson\fR キーが存在して、値がfalseでない場合、井桁とスラッシュの間の HTMLはレンダリングされ、複数回表示されます。
.
.P
値が空ではないリストの場合、リストの要素数分だけブロック内のテキストが表示されます。 ブロックのコンテキストは繰り返し処理の中の現在の要素になります。 このようにしてコレクションをループさせることができます。
.
.P
Template:
.
.IP "" 4
.
.nf

{{#repo}}
  <b>{{name}}</b>
{{/repo}}
.
.fi
.
.IP "" 0
.
.P
Hash:
.
.IP "" 4
.
.nf

{
  "repo": [
    { "name": "resque" },
    { "name": "hub" },
    { "name": "rip" }
  ]
}
.
.fi
.
.IP "" 0
.
.P
Output:
.
.IP "" 4
.
.nf

<b>resque</b>
<b>hub</b>
<b>rip</b>
.
.fi
.
.IP "" 0
.
.P
\fBLambdas: ラムダ\fR
.
.P
値が呼び出し可能オブジェクトの場合、例えば関数やラムダの場合、 そのオブジェクトが呼び出され、テキストのブロックが渡されます。渡されるテキストは 文字列ブロックでありレンダリングされていません。 \fB{{tags}}\fR は展開されません。 ラムダが自分自身でレンダリングすべきです。このようにしてフィルターやキャッシュを実現できます。
.
.P
Template:
.
.IP "" 4
.
.nf

{{#wrapped}}
  {{name}} is awesome\.
{{/wrapped}}
.
.fi
.
.IP "" 0
.
.P
Hash:
.
.IP "" 4
.
.nf

{
  "name": "Willy",
  "wrapped": function() {
    return function(text, render) {
      return "<b>" + render(text) + "</b>"
    }
  }
}
.
.fi
.
.IP "" 0
.
.P
Output:
.
.IP "" 4
.
.nf

<b>Willy is awesome\.</b>
.
.fi
.
.IP "" 0
.
.P
\fBNon\-False Values: Falseではない値\fR
.
.P
値がfalseでもリストでもない場合、ブロックを1度だけレンダリングするコンテキスト として使用されます。
.
.P
Template:
.
.IP "" 4
.
.nf

{{#person?}}
  Hi {{name}}!
{{/person?}}
.
.fi
.
.IP "" 0
.
.P
Hash:
.
.IP "" 4
.
.nf

{
  "person?": { "name": "Jon" }
}
.
.fi
.
.IP "" 0
.
.P
Output:
.
.IP "" 4
.
.nf

Hi Jon!
.
.fi
.
.IP "" 0
.
.SS "Inverted Sections: 逆セクション"
逆セクションはハットで始まり、スラッシュで終わります。つまり \fB{{^person}}\fR で"person"逆セクションが始まり \fB{{/person}}\fR で終わるということです。
.
.P
セクションはキーの値によって1回以上テキストをレンダリングするためのものですが、 逆セクションはキーの逆値にもとづいてテキストをレンダリングします。 つまり、キーが存在しない場合、falseの場合、または空リストの場合にレンダリングされる ということです。
.
.P
Template:
.
.IP "" 4
.
.nf

{{#repo}}
  <b>{{name}}</b>
{{/repo}}
{{^repo}}
  No repos :(
{{/repo}}
.
.fi
.
.IP "" 0
.
.P
Hash:
.
.IP "" 4
.
.nf

{
  "repo": []
}
.
.fi
.
.IP "" 0
.
.P
Output:
.
.IP "" 4
.
.nf

No repos :(
.
.fi
.
.IP "" 0
.
.SS "Comments: コメント"
コメントはビックリマークで始まって、無視されます。例えばこんなテンプレートは:
.
.IP "" 4
.
.nf

<h1>Today{{! ignore me }}\.</h1>
.
.fi
.
.IP "" 0
.
.P
次のようにレンダリングされます:
.
.IP "" 4
.
.nf

<h1>Today\.</h1>
.
.fi
.
.IP "" 0
.
.P
コメントは改行を含むこともできます。
.
.SS "Partials: パーシャル"
パーシャルは大なり記号で始まります: \fB{{> box}}\fR
.
.P
パーシャルは(コンパイル時ではなく)ランタイム時にレンダリングされます。 そのため、パーシャルは再帰が可能です。でも、無限ループは避けてね。
.
.P
また、呼び出し元のコンテキストが継承されます。例えばERBだとこのようになるのですが:
.
.IP "" 4
.
.nf

<%= partial :next_more, :start => start, :size => size %>
.
.fi
.
.IP "" 0
.
.P
Mustacheはこれだけです:
.
.IP "" 4
.
.nf

{{> next_more}}
.
.fi
.
.IP "" 0
.
.P
なぜでしょうか？それは \fBnext_more\.mustache\fR ファイルが呼び出し元のコンテキストの \fBsize\fR と \fBstart\fR を継承するからです。
.
.P
このようにして、パーシャルをインクルードやテンプレート拡張として使用することができます。 文字通りではありませんが。
.
.P
例えば、このテンプレートとパーシャルを使用すると:
.
.IP "" 4
.
.nf

base\.mustache:
<h2>Names</h2>
{{#names}}
  {{> user}}
{{/names}}

user\.mustache:
<strong>{{name}}</strong>
.
.fi
.
.IP "" 0
.
.P
このように1つのテンプレートに展開されたテンプレートのように考えられます:
.
.IP "" 4
.
.nf

<h2>Names</h2>
{{#names}}
  <strong>{{name}}</strong>
{{/names}}
.
.fi
.
.IP "" 0
.
.SS "Set Delimiter: 区切り文字の指定"
区切り文字指定タグはイコール記号で始まり、 区切り文字を \fB{{\fR と \fB}}\fR からカスタム文字列に変更します。
.
.P
例を見てみましょう:
.
.IP "" 4
.
.nf

* {{default_tags}}
{{=<% %>=}}
* <% erb_style_tags %>
<%={{ }}=%>
* {{ default_tags_again }}
.
.fi
.
.IP "" 0
.
.P
3つの要素をもつリストがあります。最初の要素はデフォルトタグスタイルです。 2番目は、区切り文字指定タグで指定されたERBスタイル。 そして3番目は、再度区切り文字指定タグで指定されて、デフォルトタグに戻っています。
.
.P
ctemplates \fIhttp://google\-ctemplate\.googlecode\.com/svn/trunk/doc/howto\.html\fR によるとこれは "Texのような言語にとって有用です。 二重括弧がテキストの中に出てきて、マークアップとして使用するのに不便な場合があるのです。"
.
.P
空白文字列やイコール記号はカスタム区切り文字としては使用できません。
.
.SH "COPYRIGHT"
Mustache is Copyright (C) 2009 Chris Wanstrath
.
.P
Original CTemplate by Google
.
.SH "SEE ALSO"
mustache(1), \fIhttp://mustache\.github\.io/\fR
